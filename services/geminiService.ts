
import { GoogleGenAI } from "@google/genai";
import { ImageSize } from "../types";

const getApiKey = (): string => {
  const savedKey = localStorage.getItem('custom_gemini_api_key');
  if (savedKey) {
    try {
      return atob(savedKey);
    } catch (e) {
      return savedKey;
    }
  }
  return (process.env.API_KEY as string) || '';
};

export const testGeminiConnection = async (tempKey?: string): Promise<boolean> => {
  const key = tempKey || getApiKey();
  if (!key) return false;

  try {
    const ai = new GoogleGenAI({ apiKey: key });
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: 'Connection test.',
    });
    return !!response.text;
  } catch (error) {
    console.error("Connection test failed:", error);
    throw error;
  }
};

const getClosestAspectRatio = (width: number, height: number): "1:1" | "3:4" | "4:3" | "9:16" | "16:9" => {
  const ratio = width / height;
  if (ratio > 1.5) return "16:9";
  if (ratio > 1.2) return "4:3";
  if (ratio > 0.8) return "1:1";
  if (ratio > 0.6) return "3:4";
  return "9:16";
};

export const enhanceImageWithGemini = async (dataUrl: string, size: ImageSize = '1K'): Promise<string> => {
  const apiKey = getApiKey();
  if (!apiKey) throw new Error("API 키가 설정되지 않았습니다.");

  const ai = new GoogleGenAI({ apiKey });
  
  const match = dataUrl.match(/^data:(image\/[a-z]+);base64,(.+)$/);
  if (!match) throw new Error("이미지 데이터 형식이 올바르지 않습니다.");
  
  const mimeType = match[1];
  const base64Data = match[2];

  const getDimensions = (): Promise<{width: number, height: number}> => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ width: img.width, height: img.height });
      img.src = dataUrl;
    });
  };

  const { width, height } = await getDimensions();
  const calculatedAspectRatio = getClosestAspectRatio(width, height);

  const isHighRes = size === '2K' || size === '4K';
  const modelName = isHighRes ? 'gemini-3-pro-image-preview' : 'gemini-2.5-flash-image';

  try {
    const response = await ai.models.generateContent({
      model: modelName,
      contents: {
        parts: [
          { inlineData: { data: base64Data, mimeType: mimeType } },
          { text: "Restore and upscale this image. Remove all overlays." }
        ],
      },
      config: {
        systemInstruction: `You are an expert image restoration AI. 
        Your primary goal is to provide a clean, high-resolution version of the input image.
        
        STRICT RULES:
        1. REMOVE all watermarks, black boxes, white text labels, and UI elements.
        2. CLEAN UP any descriptive bounding boxes or artifacts generated by AI systems.
        3. RECONSTRUCT the background behind any removed text or boxes using context-aware inpainting.
        4. Output ONLY the image data part. NO text response, NO descriptions.
        5. DO NOT add any new text, labels, or boxes to the output image.`,
        imageConfig: {
          aspectRatio: calculatedAspectRatio,
          ...(isHighRes ? { imageSize: size } : {})
        }
      }
    });

    let resultImage: string | null = null;
    if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          resultImage = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
          break;
        }
      }
    }
    
    if (resultImage) return resultImage;
    throw new Error("결과 이미지를 받지 못했습니다.");

  } catch (error: any) {
    const errorMsg = error?.message || "";
    if (errorMsg.includes("403") || errorMsg.includes("permission")) {
      throw new Error("MODEL_ACCESS_DENIED");
    }
    throw error;
  }
};
